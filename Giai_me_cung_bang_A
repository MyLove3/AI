# Giáº£i mÃª cung báº±ng A*

from queue import PriorityQueue
from collections import defaultdict
import random

# Táº¡o tá»« Ä‘iá»ƒn cÃ¡c kÃ½ hiá»‡u
symbols = {'.': 'â¬œ',  # ÄÆ°á»ng Ä‘i
           '#': 'â¬›',  # TÆ°á»ng
           'S': 'ğŸ‘¸',  # Start
           'G': 'ğŸ¯',  # Goal
           'W': 'ğŸŸ¥'}  # Way

def generate_maze(rows, cols):
    maze = []
    start = (random.randint(0, rows-1), random.randint(0, cols-1))
    goal = (random.randint(0, rows-1), random.randint(0, cols-1))
    while start == goal:
        goal = (random.randint(0, rows-1), random.randint(0, cols-1))
    for i in range(rows):
        row = []
        for j in range(cols):
            if (i, j) == start:
                row.append('S')
            elif (i, j) == goal:
                row.append('G')
            else:
                symbol = random.choice(['#', '.', '.'])
                row.append(symbol)
        maze.append(row)
    return maze


# Váº½ mÃª cung ban Ä‘áº§u
def draw_maze(maze):   
    print('MÃª cung ban Ä‘áº§u:\n')
    for i in range(len(maze)):
        for j in range(len(maze[i])):
            if maze[i][j] == 'S':
                print(symbols['S'], end='')
            elif maze[i][j] == 'G':
                print(symbols['G'], end='')
            elif maze[i][j] == '.':
                print(symbols['.'], end='')
            else:
                print(symbols['#'], end='')
        print()
    print() 

# Láº¥y tá»a Ä‘á»™ start vÃ  goal
def get_start_and_goal(maze):
    start = None
    goal = None
    for i in range(len(maze)):
        for j in range(len(maze[i])):
            if maze[i][j] == 'S':
                print(f'Found start node at ({i}, {j})\n')
                start = (i, j)
            elif maze[i][j] == 'G':
                print(f'Found goal node at ({i}, {j})\n')
                goal = (i, j) 
    return start, goal



def heuristic(node, goal):
    # TÃ­nh toÃ¡n giÃ¡ trá»‹ heuristic tá»« node Ä‘áº¿n goal
    # Tráº£ vá» khoáº£ng cÃ¡ch Manhattan giá»¯a node vÃ  goal
    return abs(node[0] - goal[0]) + abs(node[1] - goal[1])


def a_star(maze, start, goal):
    # Giáº£i mÃª cung báº±ng thuáº­t toÃ¡n A*
    # Tráº£ vá» Ä‘Æ°á»ng Ä‘i ngáº¯n nháº¥t tá»« start Ä‘áº¿n goal

    # Táº¡o má»™t set Ä‘á»ƒ lÆ°u cÃ¡c node Ä‘Ã£ xÃ©t
    closed_set = set()

    # Táº¡o má»™t PriorityQueue Ä‘á»ƒ lÆ°u cÃ¡c node cáº§n xÃ©t
    open_set = PriorityQueue()

    # ÄÆ°a node start vÃ o open_set vá»›i cost = 0 vÃ  priority = heuristic(start, goal)
    open_set.put((heuristic(start, goal), 0, start))

    # Táº¡o má»™t dictionary Ä‘á»ƒ lÆ°u trá»¯ thÃ´ng tin vá» parent node vÃ  cost Ä‘áº¿n node Ä‘Ã³
    came_from = {}
    cost_so_far = {}
    came_from[start] = None
    cost_so_far[start] = 0

    found_path = False  # Biáº¿n kiá»ƒm tra xem Ä‘Ã£ tÃ¬m tháº¥y Ä‘Æ°á»ng Ä‘i hay chÆ°a

    while not open_set.empty():
        # Láº¥y ra node cÃ³ priority tháº¥p nháº¥t trong open_set
        current = open_set.get()[2]
        if current == goal:
            # ÄÃ£ tÃ¬m tháº¥y Ä‘Æ°á»ng Ä‘i ngáº¯n nháº¥t tá»« start Ä‘áº¿n goal
            found_path = True
            break

        # ÄÃ¡nh dáº¥u node hiá»‡n táº¡i lÃ  Ä‘Ã£ xÃ©t
        closed_set.add(current)

        # Kiá»ƒm tra cÃ¡c node lÃ¢n cáº­n cá»§a node hiá»‡n táº¡i
        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            x, y = current[0] + dx, current[1] + dy
            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and maze[x][y] != '#':
                # TÃ­nh toÃ¡n cost tá»« start Ä‘áº¿n node káº¿ tiáº¿p
                new_cost = cost_so_far[current] + 1
                if (x, y) not in cost_so_far or new_cost < cost_so_far[(x, y)]:
                    # Náº¿u node chÆ°a Ä‘Æ°á»£c xÃ©t hoáº·c cost má»›i nhá» hÆ¡n cost cÅ©

                    # Cáº­p nháº­t thÃ´ng tin cost vÃ  parent node cá»§a node káº¿ tiáº¿p
                    cost_so_far[(x, y)] = new_cost
                    came_from[(x, y)] = current

                    # TÃ­nh toÃ¡n priority cá»§a node káº¿ tiáº¿p vÃ  Ä‘Æ°a vÃ o open_set
                    priority = new_cost + heuristic((x, y), goal)
                    open_set.put((priority, new_cost, (x, y)))

                    # In ra thÃ´ng tin cá»§a node káº¿ tiáº¿p náº¿u Ä‘Ã£ tÃ¬m tháº¥y Ä‘Æ°á»ng Ä‘i
  
                    print(f'Node ({x}, {y}): cost={new_cost}, heuristic={heuristic((x, y), goal)}')
                    print()

    # Táº¡o Ä‘Æ°á»ng Ä‘i tá»« start Ä‘áº¿n goal
    if found_path:

        # In ra Ä‘Æ°á»ng Ä‘i ngáº¯n nháº¥t náº¿u tÃ¬m tháº¥y Ä‘Æ°á»ng
        path = []
        node = goal
        while node != start:
            path.append(node)
            node = came_from[node]
        path.append(start)
        path.reverse()
    path = []
    current = goal
    while current != start:
        path.append(current)
        if current in came_from:
            current = came_from[current]
            
        else:
            # KhÃ´ng tÃ¬m tháº¥y Ä‘Æ°á»ng Ä‘i tá»« start Ä‘áº¿n goal
            print("KhÃ´ng tÃ¬m tháº¥y Ä‘Æ°á»ng Ä‘i tá»« start Ä‘áº¿n goal.\n")
            draw_maze(maze)
            return []

    path.append(start)
    path.reverse()
    path_set = set(path)
    
    print("Vay duong di ngan nhat la: ")
    print("->".join(str(p) for p in path))
    print()


    # ÄÆ°á»ng Ä‘i theo A*  
    draw_maze(maze) 
    print('ÄÆ°á»ng Ä‘i theo A*:\n')
    for i, row in enumerate(maze):
        for j, col in enumerate(row):
            if (i,j) == start:
                print(symbols['S'], end='')  # KÃ½ hiá»‡u node start
            elif (i, j) == goal:
                print(symbols['G'], end='')  # KÃ½ hiá»‡u node goal
            elif (i, j) in path_set:
                print(symbols['W'], end='')  # KÃ½ hiá»‡u Ä‘Æ°á»ng Ä‘Ã£ Ä‘i
            else:
                print(symbols[col], end='')
        print()
    return path





#Main 
rows = 10
cols = 10

maze = generate_maze(rows, cols)
start, goal = get_start_and_goal(maze)

path = a_star(maze, start, goal)
