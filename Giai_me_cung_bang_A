# Giải mê cung bằng A*

from queue import PriorityQueue
from collections import defaultdict
import random

# Tạo từ điển các ký hiệu
symbols = {'.': '⬜',  # Đường đi
           '#': '⬛',  # Tường
           'S': '👸',  # Start
           'G': '🎯',  # Goal
           'W': '🟥'}  # Way

def generate_maze(rows, cols):
    maze = []
    start = (random.randint(0, rows-1), random.randint(0, cols-1))
    goal = (random.randint(0, rows-1), random.randint(0, cols-1))
    while start == goal:
        goal = (random.randint(0, rows-1), random.randint(0, cols-1))
    for i in range(rows):
        row = []
        for j in range(cols):
            if (i, j) == start:
                row.append('S')
            elif (i, j) == goal:
                row.append('G')
            else:
                symbol = random.choice(['#', '.', '.'])
                row.append(symbol)
        maze.append(row)
    return maze


# Vẽ mê cung ban đầu
def draw_maze(maze):   
    print('Mê cung ban đầu:\n')
    for i in range(len(maze)):
        for j in range(len(maze[i])):
            if maze[i][j] == 'S':
                print(symbols['S'], end='')
            elif maze[i][j] == 'G':
                print(symbols['G'], end='')
            elif maze[i][j] == '.':
                print(symbols['.'], end='')
            else:
                print(symbols['#'], end='')
        print()
    print() 

# Lấy tọa độ start và goal
def get_start_and_goal(maze):
    start = None
    goal = None
    for i in range(len(maze)):
        for j in range(len(maze[i])):
            if maze[i][j] == 'S':
                print(f'Found start node at ({i}, {j})\n')
                start = (i, j)
            elif maze[i][j] == 'G':
                print(f'Found goal node at ({i}, {j})\n')
                goal = (i, j) 
    return start, goal



def heuristic(node, goal):
    # Tính toán giá trị heuristic từ node đến goal
    # Trả về khoảng cách Manhattan giữa node và goal
    return abs(node[0] - goal[0]) + abs(node[1] - goal[1])


def a_star(maze, start, goal):
    # Giải mê cung bằng thuật toán A*
    # Trả về đường đi ngắn nhất từ start đến goal

    # Tạo một set để lưu các node đã xét
    closed_set = set()

    # Tạo một PriorityQueue để lưu các node cần xét
    open_set = PriorityQueue()

    # Đưa node start vào open_set với cost = 0 và priority = heuristic(start, goal)
    open_set.put((heuristic(start, goal), 0, start))

    # Tạo một dictionary để lưu trữ thông tin về parent node và cost đến node đó
    came_from = {}
    cost_so_far = {}
    came_from[start] = None
    cost_so_far[start] = 0

    found_path = False  # Biến kiểm tra xem đã tìm thấy đường đi hay chưa

    while not open_set.empty():
        # Lấy ra node có priority thấp nhất trong open_set
        current = open_set.get()[2]
        if current == goal:
            # Đã tìm thấy đường đi ngắn nhất từ start đến goal
            found_path = True
            break

        # Đánh dấu node hiện tại là đã xét
        closed_set.add(current)

        # Kiểm tra các node lân cận của node hiện tại
        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            x, y = current[0] + dx, current[1] + dy
            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and maze[x][y] != '#':
                # Tính toán cost từ start đến node kế tiếp
                new_cost = cost_so_far[current] + 1
                if (x, y) not in cost_so_far or new_cost < cost_so_far[(x, y)]:
                    # Nếu node chưa được xét hoặc cost mới nhỏ hơn cost cũ

                    # Cập nhật thông tin cost và parent node của node kế tiếp
                    cost_so_far[(x, y)] = new_cost
                    came_from[(x, y)] = current

                    # Tính toán priority của node kế tiếp và đưa vào open_set
                    priority = new_cost + heuristic((x, y), goal)
                    open_set.put((priority, new_cost, (x, y)))

                    # In ra thông tin của node kế tiếp nếu đã tìm thấy đường đi
  
                    print(f'Node ({x}, {y}): cost={new_cost}, heuristic={heuristic((x, y), goal)}')
                    print()

    # Tạo đường đi từ start đến goal
    if found_path:

        # In ra đường đi ngắn nhất nếu tìm thấy đường
        path = []
        node = goal
        while node != start:
            path.append(node)
            node = came_from[node]
        path.append(start)
        path.reverse()
    path = []
    current = goal
    while current != start:
        path.append(current)
        if current in came_from:
            current = came_from[current]
            
        else:
            # Không tìm thấy đường đi từ start đến goal
            print("Không tìm thấy đường đi từ start đến goal.\n")
            draw_maze(maze)
            return []

    path.append(start)
    path.reverse()
    path_set = set(path)
    
    print("Vay duong di ngan nhat la: ")
    print("->".join(str(p) for p in path))
    print()


    # Đường đi theo A*  
    draw_maze(maze) 
    print('Đường đi theo A*:\n')
    for i, row in enumerate(maze):
        for j, col in enumerate(row):
            if (i,j) == start:
                print(symbols['S'], end='')  # Ký hiệu node start
            elif (i, j) == goal:
                print(symbols['G'], end='')  # Ký hiệu node goal
            elif (i, j) in path_set:
                print(symbols['W'], end='')  # Ký hiệu đường đã đi
            else:
                print(symbols[col], end='')
        print()
    return path





#Main 
rows = 10
cols = 10

maze = generate_maze(rows, cols)
start, goal = get_start_and_goal(maze)

path = a_star(maze, start, goal)
